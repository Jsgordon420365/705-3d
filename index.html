<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>705 Chestnut St - 3D Apartment Model</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background-color: #f0f0f0;
        }
        
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.85); /* Slightly more opaque for readability */
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            /* transition: all 0.3s ease; */
            transition-property: opacity, transform; /* More specific transitions */
            transition-duration: 0.3s;
            transition-timing-function: ease;
        }
        
        #info-panel h1 {
            margin-bottom: 10px;
            font-size: 18px;
            color: #333;
        }
        
        #info-panel p {
            margin-bottom: 6px;
            font-size: 14px;
            color: #555;
        }
        
        #unit-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(34, 34, 34, 0.85);
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 100;
            /* transition: all 0.3s ease; */
            transition-property: opacity, transform; /* More specific transitions */
            transition-duration: 0.3s;
            transition-timing-function: ease;
            opacity: 0;
            transform: translateY(20px);
        }
        
        #unit-info.active {
            opacity: 1;
            transform: translateY(0);
        }
        
        #unit-info h2 {
            margin-bottom: 10px;
            font-size: 18px;
            color: #fff;
        }
        
        #unit-info p {
            margin-bottom: 6px;
            font-size: 14px;
            color: #ddd;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.85); /* Slightly more opaque */
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
        }
        
        #controls p {
            margin-bottom: 8px;
            font-size: 14px;
            color: #333;
        }
        
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
            /* aria-hidden initially true, will be set to false by JS when hidden */
        }
        
        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading" aria-hidden="false">
        <div class="loader"></div>
    </div>
    
    <div id="canvas-container"></div>
    
    <div id="info-panel">
        <h1>705 Chestnut St, Greensboro, NC</h1>
        <p><strong>Building Type:</strong> Single-story apartment</p>
        <p><strong>Units:</strong> 8 apartment units</p>
        <p><strong>Lot Size:</strong> ~0.84 acres</p>
        <p><strong>Features:</strong> Yellow brick, white doors</p>
    </div>
    
    <div id="unit-info">
        <h2>Unit Information</h2>
        <p id="unit-number">Unit: </p>
        <p id="unit-size">Size: </p>
        <p id="unit-features">Features: </p>
    </div>
    
    <div id="controls">
        <p>Mouse Left: Rotate view</p>
        <p>Mouse Middle/Scroll: Zoom</p>
        <p>Mouse Right: Pan view</p>
        <p>Click on units for details</p>
    </div>
    
    <!-- Use a stable version of Three.js that's well-supported -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
    <!-- Add OrbitControls from CDN (compatible with r110) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/controls/OrbitControls.js"></script>

    <script>
    // Unit data for the apartment building
    const unitData = [
        { id: 1, number: "Unit 1", size: "1BR, 700 sq ft", features: "Recently Renovated" },
        { id: 2, number: "Unit 2", size: "2BR, 850 sq ft", features: "Corner Unit" },
        { id: 3, number: "Unit 3", size: "1BR, 700 sq ft", features: "Renovated Kitchen" },
        { id: 4, number: "Unit 4", size: "Studio, 550 sq ft", features: "Updated Bath" },
        { id: 5, number: "Unit 5", size: "1BR, 720 sq ft", features: "New Appliances" },
        { id: 6, number: "Unit 6", size: "2BR, 850 sq ft", features: "Recently Painted" },
        { id: 7, number: "Unit 7", size: "1BR, 700 sq ft", features: "Hardwood Floors" },
        { id: 8, number: "Unit 8", size: "2BR, 900 sq ft", features: "Corner Unit, Renovated" }
    ];

    // Main Three.js variables
    let scene, camera, renderer, orbitControls; // Changed 'controls' to 'orbitControls'
    const unitMeshes = [];
    let raycaster, mouse;
    let selectedUnit = null;
    let previouslyHoveredUnit = null; // For efficient hover
    const unitInfoPanel = document.getElementById('unit-info');
    const loadingScreen = document.getElementById('loading');

    // Default unit colors
    const DEFAULT_UNIT_COLOR = 0xF9C74F; // Yellow brick
    const HOVER_UNIT_EMISSIVE_COLOR = 0x553300; // Darker orange/brown glow
    const SELECTED_UNIT_COLOR = 0xFFA500; // Orange highlight

    // Initialize the scene
    function init() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue background
        
        // Create camera
        camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 15, 35); // Adjusted initial camera position slightly
        
        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Create orbit controls
        orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
        orbitControls.enableDamping = true; // an animation loop is required when either damping or auto-rotate are enabled
        orbitControls.dampingFactor = 0.05;
        orbitControls.screenSpacePanning = false;
        orbitControls.minDistance = 5;
        orbitControls.maxDistance = 100;
        orbitControls.maxPolarAngle = Math.PI / 2 - 0.05; // Prevent camera from going below ground
        orbitControls.target.set(0, 2, 0); // Set initial target slightly above ground center
        
        // Setup raycaster for interaction
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        
        // Add event listeners
        window.addEventListener('resize', onWindowResize);
        renderer.domElement.addEventListener('click', onMouseClick);
        renderer.domElement.addEventListener('mousemove', onMouseMove); // Changed from document to renderer.domElement for consistency
        
        // Build the 3D scene
        createLighting();
        createGround();
        createBuilding();
        createParkingLot();
        createTrees();
        
        // Hide loading screen
        setTimeout(() => {
            loadingScreen.classList.add('hidden');
            loadingScreen.setAttribute('aria-hidden', 'true');
        }, 1000); // Simulating load time, replace with LoadingManager for actual assets
        
        // Start animation loop
        animate();
    }
    
    // Create lighting for the scene
    function createLighting() {
        // Ambient light for overall illumination
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // Slightly increased intensity
        scene.add(ambientLight);
        
        // Directional light for shadows (like sunlight)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9); // Slightly increased intensity
        directionalLight.position.set(15, 25, 20);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048; // Increased shadow map resolution
        directionalLight.shadow.mapSize.height = 2048;

        // Optimize shadow camera frustum
        directionalLight.shadow.camera.left = -40;
        directionalLight.shadow.camera.right = 40;
        directionalLight.shadow.camera.top = 40;
        directionalLight.shadow.camera.bottom = -40;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 100; 
        // directionalLight.shadow.camera.updateProjectionMatrix(); // Not needed if set before first render
        scene.add(directionalLight);

        // const shadowHelper = new THREE.CameraHelper(directionalLight.shadow.camera); // For debugging
        // scene.add(shadowHelper);
    }
    
    // Create ground plane with grass texture
    function createGround() {
        const groundGeometry = new THREE.PlaneGeometry(80, 60); // Made ground larger
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x7CFC00,  // Lawn green
            roughness: 0.9,   // More rough for grass
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Rotate to horizontal
        ground.receiveShadow = true;
        scene.add(ground);
    }
    
    // Create the apartment building
    function createBuilding() {
        const buildingWidth = 40;
        const buildingDepth = 10;
        const buildingHeight = 4;
        const unitWidth = buildingWidth / 8; // 8 units
        
        // Building base with yellow brick material
        const buildingGeometry = new THREE.BoxGeometry(buildingWidth, buildingHeight, buildingDepth);
        const buildingMaterial = new THREE.MeshStandardMaterial({
            color: DEFAULT_UNIT_COLOR,
            roughness: 0.7,
            metalness: 0.2
        });
        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
        building.position.y = buildingHeight / 2;
        building.castShadow = true;
        building.receiveShadow = true;
        scene.add(building);
        
        // Create roof
        const roofGeometry = new THREE.BoxGeometry(buildingWidth + 0.5, 0.5, buildingDepth + 0.5); // Slightly smaller overlap
        const roofMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,  // Dark gray
            roughness: 0.6,
            metalness: 0.3
        });
        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
        roof.position.y = buildingHeight + 0.25;
        roof.castShadow = true;
        scene.add(roof);

        // Shared geometries and materials for unit parts
        const doorWidth = 1.2;
        const doorHeight = 2.5;
        const doorGeometry = new THREE.BoxGeometry(doorWidth, doorHeight, 0.2);
        const doorMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.5, metalness: 0.1 });

        const windowWidth = 1.2;
        const windowHeight = 1.5;
        const windowGeometry = new THREE.BoxGeometry(windowWidth, windowHeight, 0.1);
        const windowMaterial = new THREE.MeshStandardMaterial({ color: 0xADD8E6, roughness: 0.3, metalness: 0.3, transparent: true, opacity: 0.6 }); // Lighter blue

        const labelGeometry = new THREE.PlaneGeometry(1, 0.5);
        const labelMaterial = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
        
        // Create individual units
        for (let i = 0; i < 8; i++) {
            const unitMaterial = new THREE.MeshStandardMaterial({
                color: DEFAULT_UNIT_COLOR,
                roughness: 0.7,
                metalness: 0.2,
                emissive: 0x000000 // Initialize emissive property
            });
            const unitGeometry = new THREE.BoxGeometry(unitWidth - 0.1, buildingHeight, buildingDepth - 0.1);
            const unit = new THREE.Mesh(unitGeometry, unitMaterial);
            
            unit.position.x = -buildingWidth / 2 + unitWidth / 2 + i * unitWidth;
            unit.position.y = buildingHeight / 2;
            unit.userData = { isUnit: true, unitIndex: i, originalColor: new THREE.Color(DEFAULT_UNIT_COLOR) }; // Store original color
            
            scene.add(unit); // Add unit mesh directly to scene for easier picking
            unitMeshes.push(unit);
            
            // Add door to unit (white)
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.z = buildingDepth / 2 + 0.1; // Relative to building front
            door.position.y = -buildingHeight / 2 + doorHeight / 2; // Relative to unit bottom
            door.castShadow = true;
            unit.add(door); // Add door as child of unit
            
            // Add windows (two per unit)
            const leftWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            leftWindow.position.set(-unitWidth / 4, 0.5, buildingDepth / 2 + 0.05); // Relative to unit center
            leftWindow.castShadow = true;
            unit.add(leftWindow);
            
            const rightWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            rightWindow.position.set(unitWidth / 4, 0.5, buildingDepth / 2 + 0.05); // Relative to unit center
            rightWindow.castShadow = true;
            unit.add(rightWindow);
            
            // Add unit number text (simplified label)
            const label = new THREE.Mesh(labelGeometry, labelMaterial);
            label.position.set(0, 1.5, buildingDepth / 2 + 0.15); // Relative to unit center
            unit.add(label);
        }
    }
    
    // Create parking lot with spaces
    function createParkingLot() {
        const parkingWidth = 30; // Slightly wider
        const parkingDepth = 15;
        const parkingGeometry = new THREE.PlaneGeometry(parkingWidth, parkingDepth);
        const parkingMaterial = new THREE.MeshStandardMaterial({
            color: 0x444444,  // Darker Asphalt
            roughness: 0.9,
            metalness: 0.1
        });
        const parkingLot = new THREE.Mesh(parkingGeometry, parkingMaterial);
        parkingLot.rotation.x = -Math.PI / 2;
        parkingLot.position.set(0, 0.01, -12); // Centered X, slightly above ground
        parkingLot.receiveShadow = true;
        scene.add(parkingLot);
        
        const spaceWidth = 3;
        const spaceDepth = 6;
        const spacesPerRow = 8;
        const rows = 2;
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF, linewidth: 2 }); // Shared material

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < spacesPerRow; col++) {
                const lineGeometry = new THREE.BufferGeometry();
                const halfWidth = spaceWidth / 2 - 0.1;
                const halfDepth = spaceDepth / 2 - 0.1;
                
                const vertices = new Float32Array([
                    -halfWidth, 0, -halfDepth,  halfWidth, 0, -halfDepth,
                     halfWidth, 0, -halfDepth,  halfWidth, 0,  halfDepth,
                     halfWidth, 0,  halfDepth, -halfWidth, 0,  halfDepth,
                    -halfWidth, 0,  halfDepth, -halfWidth, 0, -halfDepth
                ]);
                lineGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                const line = new THREE.LineSegments(lineGeometry, lineMaterial); // Use LineSegments for distinct lines
                
                line.rotation.x = -Math.PI / 2; // This orients the line's local XY plane to be world XZ
                line.position.x = - (spacesPerRow * spaceWidth / 2) + spaceWidth / 2 + col * spaceWidth;
                line.position.z = -12 + (row === 0 ? -parkingDepth/4 -spaceDepth / 4 : parkingDepth/4 + spaceDepth / 4) - (spaceDepth/2 * (row === 0 ? 1: -1));
                line.position.y = 0.02; // Slightly above the parking lot
                scene.add(line);
            }
        }
    }
    
    // Create trees around the property
    function createTrees() {
        const treePositions = [
            { x: -28, z: -18 }, { x: -22, z: 18 }, { x: -18, z: -12 },
            { x: -8, z: 20 }, { x: 8, z: -20 }, { x: 18, z: 15 },
            { x: 25, z: -15 }, { x: 30, z: 18 }
        ];
        
        // Shared geometries and materials for trees
        const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.5, 3, 8); // Slimmer trunk
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9, metalness: 0.1 });
        const foliageGeometry = new THREE.SphereGeometry(2.2, 10, 8); // Slightly smaller, less segments
        const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.8, metalness: 0.1 });

        treePositions.forEach(pos => {
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(pos.x, 1.5, pos.z);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            scene.add(trunk);
            
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.set(pos.x, 4.2, pos.z); // Adjusted foliage height
            foliage.castShadow = true;
            foliage.receiveShadow = true;
            scene.add(foliage);
        });
    }
    
    // Handle window resizing
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // Handle mouse click events for unit selection
    function onMouseClick(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(unitMeshes, true); // Intersect only unitMeshes and their children
        
        let clickedUnitObj = null;
        if (intersects.length > 0) {
            let obj = intersects[0].object;
            while(obj && !obj.userData.isUnit && obj.parent){
                obj = obj.parent;
            }
            if(obj && obj.userData.isUnit){
                clickedUnitObj = obj;
            }
        }

        if (clickedUnitObj) {
            selectUnit(clickedUnitObj.userData.unitIndex);
        } else if (selectedUnit !== null && event.target === renderer.domElement) { 
            // Deselect if clicked on canvas but not on a unit
            deselectUnit();
        }
    }
    
    // Handle mouse move for hover effects
    function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(unitMeshes, true); // Intersect only unitMeshes and their children

        let currentHoveredUnitObj = null;
        if (intersects.length > 0) {
            let obj = intersects[0].object;
            while(obj && !obj.userData.isUnit && obj.parent){
                obj = obj.parent;
            }
            if(obj && obj.userData.isUnit){
                currentHoveredUnitObj = obj;
            }
        }

        // If there was a previously hovered unit, and it's not the current one, and not selected
        if (previouslyHoveredUnit && previouslyHoveredUnit !== currentHoveredUnitObj && previouslyHoveredUnit !== selectedUnit) {
            previouslyHoveredUnit.material.emissive.setHex(0x000000); // Reset emissive
            // Optionally reset base color if hover changed it:
            // previouslyHoveredUnit.material.color.setHex(previouslyHoveredUnit.userData.originalColor.getHex());
        }

        // If there's a current hovered unit, and it's not selected
        if (currentHoveredUnitObj && currentHoveredUnitObj !== selectedUnit) {
            currentHoveredUnitObj.material.emissive.setHex(HOVER_UNIT_EMISSIVE_COLOR);
            renderer.domElement.style.cursor = 'pointer';
        } else {
            renderer.domElement.style.cursor = 'default';
        }
        previouslyHoveredUnit = currentHoveredUnitObj;
    }
    
    // Select a unit
    function selectUnit(index) {
        // Deselect previous if any unit is selected
        if (selectedUnit !== null) {
            deselectUnit();
        }
        
        selectedUnit = unitMeshes[index];
        
        // Clear any hover effect from the unit being selected
        selectedUnit.material.emissive.setHex(0x000000); 
        selectedUnit.material.color.setHex(SELECTED_UNIT_COLOR); // Apply selection color
        
        const unitInfo = unitData[index];
        document.getElementById('unit-number').textContent = `Unit: ${unitInfo.number}`;
        document.getElementById('unit-size').textContent = `Size: ${unitInfo.size}`;
        document.getElementById('unit-features').textContent = `Features: ${unitInfo.features}`;
        unitInfoPanel.classList.add('active');

        // If the selected unit was the previously hovered one, clear previouslyHoveredUnit
        if (previouslyHoveredUnit === selectedUnit) {
            previouslyHoveredUnit = null; 
        }
    }
    
    // Deselect current unit
    function deselectUnit() {
        if (selectedUnit !== null) {
            selectedUnit.material.color.setHex(selectedUnit.userData.originalColor.getHex()); // Reset to original color
            selectedUnit.material.emissive.setHex(0x000000); // Reset emissive
            selectedUnit = null;
            unitInfoPanel.classList.remove('active');
        }
    }
    
    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        orbitControls.update(); // Only required if controls.enableDamping or controls.autoRotate are set to true
        renderer.render(scene, camera);
    }
    
    // Start the application
    init();
    </script>
</body>
</html>